#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
from Packet import Packet




def main():
        id = sys.argv[1]
        LAN = sys.argv[2:]
        sockets = []

        # creates sockets and connects to them
        for x in range(len(LAN)):
                s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                s.connect(pad(LAN[x]))
                sockets.append(s)

        print "Bridge " + id + " starting up\n"

        # Main loop
        while True:
            # Calls select with all the sockets; change the timeout value (1)
            ready, ignore, ignore2 = select.select(sockets, [], [], 1)

            # Reads from each fo the ready sockets
            for x in ready:
                message = x.recv(1500)
                print "DATA: ", message
                packet = Packet(message)


# pads the name with null bytes at the end
def pad(name):
        result = '\0' + name
        while len(result) < 108:
                result += '\0'
        return result

'''
def parse_to_packet(message):
    json_message = json.loads(message)
    message_source = json_message['source']
    message_dest = json_message['dest']
    message_type = json_message['type']
    message_message = json_message['message']
    print "Source: ", json_message['source']
    print "Dest: ", json_message['dest']
    print "Type: ", json_message['type']
    print "Message: ", json_message['message']
    # return Packet(message_source, message_dest, message_type message_message)


def parse_packet_message(packet_message):
    packet_message = json.loads(packet_message)
    message_id = packet_message['id']
    message_root = ""
    message_cost = ""
    if packet_message['root']:
        message_root = packet_message['root']
    if packet_message['cost']:
        message_cost = packet_message['cost']

'''

if __name__ == "__main__":
    main()
